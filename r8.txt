# russian_roulette_bot.py
# Ù†ÛŒØ§Ø²Ù…Ù†Ø¯: python-telegram-bot v20+ (async)
import asyncio
import random
from typing import Dict, List, Optional
from dataclasses import dataclass, field

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters

# ====== Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ ======
TOKEN = "7324627431:AAH8CInOMAbNJB-ZQWAoru0iDFVJYE4IyRM"  # Ø§ÛŒÙ†Ø¬Ø§ ØªÙˆÚ©Ù† Ø¨Ø§Øªâ€ŒØªÙˆ Ø¨Ø°Ø§Ø±

# ====== Ù…Ø¯Ù„ Ø¯Ø§Ø¯Ù‡ Ø¨Ø§Ø²ÛŒ ======
@dataclass
class Game:
    chat_id: int
    players: List[int] = field(default_factory=list)        # Ø´Ù†Ø§Ø³Ù‡â€ŒÙ‡Ø§ÛŒ ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†
    player_names: Dict[int, str] = field(default_factory=dict)  # id -> Ù†Ø§Ù… Ù†Ù…Ø§ÛŒØ´
    current_index: int = 0
    chambers: List[bool] = field(default_factory=list)  # True=Ú¯Ù„ÙˆÙ„Ù‡ØŒ False=Ø®Ø§Ù„ÛŒ
    started: bool = False
    eliminated: List[int] = field(default_factory=list)

    def reset_chambers(self, chambers_count: int = 6, bullets: int = 1):
        # Ø§ÛŒØ¬Ø§Ø¯ ÛŒÚ© Ø¯ÙˆØ± Ø¬Ø¯ÛŒØ¯: ÛŒÚ© Ú¯Ù„ÙˆÙ„Ù‡ Ø¯Ø± Ù†ÙÙ‡ Ø®Ø§Ù† Ú¯Ø°Ø§Ø´ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 1 Ú¯Ù„ÙˆÙ„Ù‡/6 Ø®Ø§Ù†)
        arr = [False] * chambers_count
        for _ in range(bullets):
            pos = random.randrange(0, chambers_count)
            while arr[pos]:
                pos = random.randrange(0, chambers_count)
            arr[pos] = True
        random.shuffle(arr)
        self.chambers = arr
        self.current_index = 0

    def spin_and_shoot(self) -> bool:
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¢Ø®Ø±ÛŒÙ† Ø®Ø§Ù† Ùˆ Ø¨Ø±Ú¯Ø´Øª True = Ú¯Ù„ÙˆÙ„Ù‡ Ø´Ù„ÛŒÚ© Ø´Ø¯
        if not self.chambers:
            self.reset_chambers()
        res = self.chambers[self.current_index]
        # Ù¾ÛŒØ´Ø±ÙØª Ù†ÙˆØ¨Øª (Ú¯Ø±Ø¯Ø´ÛŒ)
        self.current_index = (self.current_index + 1) % len(self.chambers)
        return res

# Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§ Ø¨Ø± Ø­Ø³Ø¨ chat_id (Ú†Øª Ú¯Ø±ÙˆÙ‡ÛŒ ÛŒØ§ Ø®ØµÙˆØµÛŒ)
GAMES: Dict[int, Game] = {}

# ====== Ú©Ù…Ú©ÛŒâ€ŒÙ‡Ø§ ======
def get_or_create_game(chat_id: int) -> Game:
    if chat_id not in GAMES:
        GAMES[chat_id] = Game(chat_id=chat_id)
    return GAMES[chat_id]

def safe_name(user) -> str:
    if user.full_name:
        return user.full_name
    return user.username or str(user.id)

# ====== Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ ======
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ğŸ¤– Ø±Ø¨Ø§Øª Ø±ÙˆÙ„Øª Ø±ÙˆØ³ÛŒ (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ). ÙØ±Ù…Ø§Ù†â€ŒÙ‡Ø§:\n"
        "/join â€” Ù¾ÛŒÙˆØ³ØªÙ† Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ\n"
        "/leave â€” Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù† Ø§Ø² Ø¨Ø§Ø²ÛŒ\n"
        "/players â€” Ù†Ù…Ø§ÛŒØ´ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†\n"
        "/newgame â€” Ø³Ø§Ø®ØªÙ† Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ (ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶)\n"
        "/startgame â€” Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ\n"
        "/shoot â€” Ø´Ù„ÛŒÚ© (Ù†ÙˆØ¨ØªÛŒ)\n"
        "/status â€” ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ\n"
        "/help â€” Ù‡Ù…ÛŒÙ† Ù¾ÛŒØ§Ù…"
    )

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await start_cmd(update, context)

async def join_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user
    game = get_or_create_game(chat_id)

    if user.id in game.players and user.id not in game.eliminated:
        await update.message.reply_text("ØªÙˆ Ù‚Ø¨Ù„Ø§Ù‹ Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ù¾ÛŒÙˆØ³ØªÛŒ.")
        return

    game.players.append(user.id)
    game.player_names[user.id] = safe_name(user)
    # Ø§Ú¯Ø± Ù‚Ø¨Ù„Ø§Ù‹ Ø­Ø°Ù Ø´Ø¯Ù‡ Ø¨ÙˆØ¯ØŒ Ø¨Ø§Ø²ÛŒ Ø±Ùˆ Ø±ÛŒØ³Øª Ø­Ø°Ù Ø¨Ø±Ø§ÛŒ Ø§ÙˆÙ†
    if user.id in game.eliminated:
        game.eliminated.remove(user.id)

    await update.message.reply_text(f"{safe_name(user)} Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ù¾ÛŒÙˆØ³Øª.")

async def leave_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user
    game = get_or_create_game(chat_id)

    if user.id in game.players:
        game.players.remove(user.id)
        game.player_names.pop(user.id, None)
        if user.id in game.eliminated:
            game.eliminated.remove(user.id)
        await update.message.reply_text(f"{safe_name(user)} Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.")
    else:
        await update.message.reply_text("ØªÙˆ Ø¹Ø¶Ùˆ Ø¨Ø§Ø²ÛŒ Ù†ÛŒØ³ØªÛŒ.")

async def players_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    game = get_or_create_game(chat_id)
    if not game.players:
        await update.message.reply_text("ÙØ¹Ù„Ø§Ù‹ Ù‡ÛŒÚ† Ø¨Ø§Ø²ÛŒÚ©Ù†ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡. Ø¨Ø§ /join Ø¨Ù¾ÛŒÙˆÙ†Ø¯.")
        return
    lines = []
    for i, pid in enumerate(game.players, start=1):
        name = game.player_names.get(pid, str(pid))
        status = "âŒ" if pid in game.eliminated else "ğŸŸ¢"
        lines.append(f"{i}. {name} {status}")
    await update.message.reply_text("Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†:\n" + "\n".join(lines))

async def newgame_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    game = get_or_create_game(chat_id)
    # Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§: Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒÙ… Ø§Ø² Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† ÙØ±Ù…Ø§Ù† ØªØ¹Ø¯Ø§Ø¯ Ø®Ø§Ù†/ØªØ¹Ø¯Ø§Ø¯ Ú¯Ù„ÙˆÙ„Ù‡ Ø±Ùˆ Ø¨Ú¯ÛŒØ±ÛŒÙ…
    args = context.args
    try:
        if len(args) >= 1:
            chambers = int(args[0])
        else:
            chambers = 6
        if len(args) >= 2:
            bullets = int(args[1])
        else:
            bullets = 1
    except ValueError:
        await update.message.reply_text("Ø§Ø³ØªÙØ§Ø¯Ù‡: /newgame [chambers] [bullets] â€” Ù…Ø«Ø§Ù„: /newgame 6 1")
        return

    game.reset_chambers(chambers_count=chambers, bullets=bullets)
    game.started = False
    game.eliminated = []
    await update.message.reply_text(f"Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯ â€” {chambers} Ø®Ø§Ù†ØŒ {bullets} Ú¯Ù„ÙˆÙ„Ù‡. Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ /startgame Ø¨Ø²Ù†.")

async def startgame_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    game = get_or_create_game(chat_id)

    if len(game.players) < 2:
        await update.message.reply_text("Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø­Ø¯Ø§Ù‚Ù„ Ø¯Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù† Ù„Ø§Ø²Ù… Ø§Ø³Øª. Ø¨Ø§ /join Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¬Ø°Ø¨ Ú©Ù†.")
        return

    if not game.chambers:
        game.reset_chambers()  # Ù¾ÛŒØ´â€ŒÙØ±Ø¶
    game.started = True
    game.eliminated = []
    # Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø´Ø±ÙˆØ¹ ØªØµØ§Ø¯ÙÛŒ
    game.current_index = random.randrange(0, len(game.chambers))
    # Ø§Ù…Ø§ current_index Ø¨Ø±Ø§ÛŒ Ø´Ù„ÛŒÚ© Ø¯Ø§Ø®Ù„ chambers Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒØ´Ù‡Ø› Ø¨Ø±Ø§ÛŒ Ù†ÙˆØ¨Øª Ø¯Ø§Ø¯Ù†ØŒ Ø¨Ù‡ØªØ± Ø¨Ø°Ø§Ø±ÛŒÙ… index Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†
    game.current_index = 0
    await update.message.reply_text(
        "ğŸ¯ Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯!\nÙ†ÙˆØ¨ØªÙ: " + game.player_names[game.players[0]] + "\nØ¨Ø±Ø§ÛŒ Ø´Ù„ÛŒÚ© /shoot Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )

async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    game = get_or_create_game(chat_id)
    text = []
    text.append(f"Ø´Ø±ÙˆØ¹ Ø´Ø¯Ù‡ØŸ {'Ø¨Ù„Ù‡' if game.started else 'Ø®ÛŒØ±'}")
    text.append(f"ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†: {len(game.players)}")
    alive = [p for p in game.players if p not in game.eliminated]
    text.append(f"Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ù…Ø§Ù†Ø¯Ù‡: {len(alive)}")
    if alive:
        names = ", ".join(game.player_names.get(pid, str(pid)) for pid in alive)
        text.append("Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø²Ù†Ø¯Ù‡: " + names)
        # Ù†ÙˆØ¨Øª ÙØ¹Ù„ÛŒ:
        curr = alive[0] if game.started else (game.players[0] if game.players else None)
        if curr:
            text.append("Ù†ÙˆØ¨Øª ÙØ¹Ù„ÛŒ: " + game.player_names.get(curr, str(curr)))
    await update.message.reply_text("\n".join(text))

async def shoot_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user
    game = get_or_create_game(chat_id)

    # Ø§ÙˆÙ„ Ú†Ú© Ú©Ù†ÛŒÙ… Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯Ù‡
    if not game.started:
        await update.message.reply_text("Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ù†Ø´Ø¯Ù‡. Ø§Ø² /startgame Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.")
        return

    if user.id not in game.players:
        await update.message.reply_text("ØªÙˆ Ø¹Ø¶Ùˆ Ø¨Ø§Ø²ÛŒ Ù†ÛŒØ³ØªÛŒ. Ø¨Ø§ /join ÙˆØ§Ø±Ø¯ Ø´Ùˆ.")
        return

    # Ù…Ø­Ø§Ø³Ø¨Ù‡â€ŒÛŒ Ù„ÛŒØ³Øª Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø²Ù†Ø¯Ù‡ Ùˆ Ù†ÙˆØ¨Øª
    alive = [p for p in game.players if p not in game.eliminated]
    if not alive:
        await update.message.reply_text("Ù‡ÛŒÚ† Ø¨Ø§Ø²ÛŒÚ©Ù†ÛŒ Ø²Ù†Ø¯Ù‡ Ù†ÛŒØ³Øª. Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ø¨Ø§ /newgame Ø±ÛŒØ³Øª Ú©Ù†.")
        return

    # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù†ÙˆØ¨Øª Ú©Ø§Ø±Ø¨Ø± Ø§Ø³Øª
    # Ù†ÙˆØ¨Øª Ø±Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ±ØªÛŒØ¨ 'alive' Ùˆ game.current_index Ù†Ú¯Ù‡ Ù…ÛŒâ€ŒØ¯Ø§Ø±ÛŒÙ…
    # ØªØ¶Ù…ÛŒÙ† Ú©Ù†ÛŒÙ… current_index Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø§Ø³Øª
    game.current_index %= len(alive)
    current_player_id = alive[game.current_index]

    if current_player_id != user.id:
        await update.message.reply_text(f"Ø§Ù„Ø§Ù† Ù†ÙˆØ¨Øª {game.player_names[current_player_id]} Ø§Ø³Øª â€” Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù† ØªØ§ Ù†ÙˆØ¨ØªØª Ø¨Ø´Ù‡.")
        return

    # Ø´Ù„ÛŒÚ©
    fired = game.spin_and_shoot()
    # Ø§Ú¯Ø± Ø´Ù„ÛŒÚ© Ø´Ø¯ -> Ø­Ø°Ù Ø¨Ø§Ø²ÛŒÚ©Ù† ÙØ¹Ù„ÛŒ
    if fired:
        game.eliminated.append(user.id)
        await update.message.reply_text(f"ğŸ’¥ Ø¨ÙˆÙ…! {safe_name(user)} Ú¯Ù„ÙˆÙ„Ù‡ Ø®ÙˆØ±Ø¯ Ùˆ Ø­Ø°Ù Ø´Ø¯.")
        # Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ: Ø§Ú¯Ø± ÙÙ‚Ø· 0 ÛŒØ§ 1 Ù†ÙØ± Ù…Ø§Ù†Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
        remaining = [p for p in game.players if p not in game.eliminated]
        if len(remaining) <= 1:
            if remaining:
                await update.message.reply_text(f"ğŸ† Ø¨Ø§Ø²ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯. Ø¨Ø±Ù†Ø¯Ù‡: {game.player_names[remaining[0]]}")
            else:
                await update.message.reply_text("Ø¨Ø§Ø²ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯ â€” Ù‡ÛŒÚ† Ø¨Ø±Ù†Ø¯Ù‡â€ŒØ§ÛŒ Ù†Ù…Ø§Ù†Ø¯.")
            game.started = False
            return
        else:
            # Ù†ÙˆØ¨Øª Ø¨Ø¹Ø¯ÛŒ: Ù‡Ù…Ø§Ù† Ø§ÛŒÙ†Ø¯Ú©Ø³ (Ú†ÙˆÙ† Ø§ÛŒÙ† Ø§ÛŒÙ†Ø¯Ú©Ø³ Ø¨Ù‡ ØªØ±ØªÛŒØ¨ alive Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ‡ Ø´Ø¯Ù‡)
            game.current_index %= len(remaining)
            await update.message.reply_text(f"Ù†ÙˆØ¨Øª Ø¨Ø¹Ø¯ÛŒ: {game.player_names[remaining[game.current_index]]}")
            return
    else:
        await update.message.reply_text(f"click... {safe_name(user)} Ø´Ø§Ù†Ø³ Ø¢ÙˆØ±Ø¯ â€” Ø³Ø§Ù„Ù… Ù…ÙˆÙ†Ø¯.")
        # Ø±ÙØªÙ† Ø¨Ù‡ Ù†ÙˆØ¨Øª Ø¨Ø¹Ø¯ÛŒ
        game.current_index = (game.current_index + 1) % len([p for p in game.players if p not in game.eliminated])
        alive = [p for p in game.players if p not in game.eliminated]
        await update.message.reply_text(f"Ù†ÙˆØ¨Øª Ø¨Ø¹Ø¯ÛŒ: {game.player_names[alive[game.current_index]]}")

async def unknown_msg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ù…ØªÙˆØ¬Ù‡ Ù†Ø´Ø¯Ù… â€” /help Ø±Ø§ Ø¨Ø²Ù† Ø¨Ø±Ø§ÛŒ ÙØ±Ù…Ø§Ù†â€ŒÙ‡Ø§.")

# ====== Ø¨ÙˆØª Ø§Ø¬Ø±Ø§ ======
def main():
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("join", join_cmd))
    app.add_handler(CommandHandler("leave", leave_cmd))
    app.add_handler(CommandHandler("players", players_cmd))
    app.add_handler(CommandHandler("newgame", newgame_cmd))
    app.add_handler(CommandHandler("startgame", startgame_cmd))
    app.add_handler(CommandHandler("shoot", shoot_cmd))
    app.add_handler(CommandHandler("status", status_cmd))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, unknown_msg))

    print("Bot started...")
    app.run_polling()

if __name__ == "__main__":
    main()



